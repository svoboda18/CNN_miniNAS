# nas/io.py
import yaml
import os
import matplotlib.pyplot as plt
import torch

def load_config(path: str) -> dict:
    """
    Opens a YAML config file and returns it as a Python dict.
    Also validates that required keys exist.
    """
    # check file exists
    if not os.path.exists(path):
        raise FileNotFoundError(f"Config file not found: {path}")

    with open(path, "r") as f:
        config = yaml.safe_load(f)

    # ---- CONFIG LANGUAGE VALIDATION  ----
    # check top level keys exist
    required_keys = ["SearchSpace", "SearchStrategy", "ValidationStrategy"]
    for key in required_keys:
        if key not in config:
            raise ValueError(f"Missing required key in config: '{key}'")

    # check SearchSpace has required fields
    ss = config["SearchSpace"]
    for field in ["layers_types", "layers_count", "channels", "kernel"]:
        if field not in ss:
            raise ValueError(f"SearchSpace missing field: '{field}'")

    # check layers_types only contains valid values
    valid_types = ["Conv2d", "MaxPool2d", "Dropout", "ReLU"]
    for t in ss["layers_types"]:
        if t not in valid_types:
            raise ValueError(f"Unknown layer type: '{t}'")

    # check nbr_iterations is a positive integer
    n = config["SearchStrategy"]["nbr_iterations"]
    if not isinstance(n, int) or n <= 0:
        raise ValueError("nbr_iterations must be a positive integer")

    print("Config loaded and validated successfully.")
    return config



def save_results(path: str, all_results: list):
    """
    Saves for each model:
    - loss_history.png
    - model.pt
    Also saves accuracies.txt and best_model_code.py
    """
    os.makedirs(path, exist_ok=True)

    accuracies = []

    for i, result in enumerate(all_results):
        # create folder for this model
        model_dir = os.path.join(path, f"model_{i}")
        os.makedirs(model_dir, exist_ok=True)

        # save loss plot
        plt.figure()
        plt.plot(result["loss_history"])
        plt.xlabel("Epoch")
        plt.ylabel("Loss")
        plt.title(f"Model {i} - Loss History")
        plt.savefig(os.path.join(model_dir, "loss_history.png"))
        plt.close()

        # save model weights (only when a real model was returned)
        if result["model"] is not None:
            torch.save(result["model"].state_dict(),
                       os.path.join(model_dir, "model.pt"))
        else:
            # Leave a placeholder so the folder is not silently empty
            with open(os.path.join(model_dir, "model_not_saved.txt"), "w") as nf:
                nf.write("Model object was None â€” training may not have run.\n")

        # collect accuracy line
        accuracies.append(f"Model {i}: acc_val = {result['acc_val']:.4f}")

    # save accuracies.txt
    with open(os.path.join(path, "accuracies.txt"), "w") as f:
        f.write("\n".join(accuracies))
    print("Saved accuracies.txt")

    # find best model and save its code
    best = max(all_results, key=lambda r: r["acc_val"])
    best_index = all_results.index(best)
    code = generate_code(best["architecture"])
    with open(os.path.join(path, "best_model_code.py"), "w") as f:
        f.write(code)
    print(f"Best model was Model {best_index} "
          f"with acc = {best['acc_val']:.4f}")
    print("Saved best_model_code.py")


def generate_code(architecture: dict) -> str:
    """
    Takes an architecture dict and generates
    a ready-to-use Python file as a string.
    """
    lines = []
    lines.append("# Auto-generated by CNN_Cls_miniNAS")
    lines.append("import torch")
    lines.append("import torch.nn as nn")
    lines.append("")
    lines.append("class BestModel(nn.Module):")
    lines.append("    def __init__(self, flat_size, num_classes=10):")
    lines.append("        super().__init__()")
    lines.append("        self.features = nn.Sequential(")

    in_ch = 1
    for layer in architecture["layers"]:
        t = layer["type"]
        if t == "Conv2d":
            out_ch = layer["channels"]          # canonical key
            k = layer["kernel"]                 # canonical key
            p = layer.get("padding", 0)
            pm = layer.get("padding_mode", "zeros")
            lines.append(
                f"            nn.Conv2d({in_ch}, {out_ch}, "
                f"kernel_size={k}, padding={p}, padding_mode='{pm}'),"
            )
            in_ch = out_ch
        elif t == "ReLU":
            lines.append("            nn.ReLU(),")
        elif t == "MaxPool2d":
            lines.append("            nn.MaxPool2d(2),")
        elif t == "Dropout":
            rate = layer.get("rate", 0.1)
            lines.append(f"            nn.Dropout({rate}),")

    lines.append("        )")
    lines.append("")

    last_hid = architecture.get("last_hid_mlp", 0)
    lines.append("        self.classifier = nn.Sequential(")
    lines.append("            nn.Flatten(),")
    if last_hid > 0:
        lines.append(f"            nn.Linear(flat_size, {last_hid}),")
        lines.append(f"            nn.Linear({last_hid}, num_classes),")
    else:
        lines.append(f"            nn.Linear(flat_size, num_classes),")
    lines.append("        )")
    lines.append("")
    lines.append("    def forward(self, x):")
    lines.append("        x = self.features(x)")
    lines.append("        return self.classifier(x)")

    return "\n".join(lines)